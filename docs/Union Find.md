---
slug    : /algorithm/union-find
title   : union find 알고리즘에 대해 알아보자
description : 
date    : 2023-01-02 02:22:37 +0900
---

## 풀고자 하는 문제
두개의 대상이 서로 같은 집합에 속하는지 빠르게 판단하고 싶은 경우에 사용한다. 그래프에서 두 노드 사이에 연결이 존재하는지를 판단할때 활용한다. 

## 자료구조의 인터페이스 
`union(a:Node, b:Node)`과 `isConnected(a: Node, b: Node)`를 public method로 설계할 수 있다.
> - union(a, b) 는 두 지점을 연결시키는 메서드이다. 
> - isConnected(a, b) 는 두 지점이 연결되어 있는지 (같은 connected component에 속하는지) 여부를 반환한다. 

## 알고리즘 
### Quick find
이름처럼 `isConnected` 연산의 시간복잡도가 `O(1)`으로 빠른 연산이다. 대신에 `union` 연산의 시간복잡도가 높다. 구체적인 사항은 다음과 같다. 

> - 노드 수 만큼의 배열을 준비한다. 
> - 대표 아이디 배열을 초기화 한다. 인덱스가 노드 번호이고 값은 노드가 속한 component의 대표 아이디이다. 
> - isConnected 연산에서는 두개의 노드가 서로 같은 대표 아이디를 가졌는지 확인하면 된다> - union 연산의 경우, 두 인덱스의 값을 하나로 통일시켜주고, 두 노드가 속한 컴포넌트 값을 가진 인덱스들을 모두가 같은 값으로 만들어야 한다. 

## Quick union 
`union`연산의 시간복잡도를 낮추고 `isConnected` 연산의 시간복잡도를 늘린 경우이다. 
> - `isConnected` 연산의 경우 두 노드의 루트가 같은지를 검사한다.  
> - `union` 연산은 두개의 값을 둘 중 하나로 통일 시키면 된다. 

## Quick union weighted
불행히도 위 두 알고리즘 모두 느리다. 가중치를 주는 방식을 통해서 빠른 알고리즘으로 변화시킬 수 있다. 가중치는 해당 컴포넌트에 속하는 노드의 개수로, 원소의 개수가 작은 쪽이 더아래로 가레된다. 

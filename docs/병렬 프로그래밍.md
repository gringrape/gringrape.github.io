---
slug    : /java/parallel
title   : 자바 병렬 프로그래밍 기본 원리
description : 
date    : 2022-10-04 11:22:42 +0900
---

## 스레드를 사용하는 예시
> 서블릿이나 RMI 같은 컴포넌트 프레임웍 역시 스레드를 관리하는 풀을 여러 개 생성하고 이 스레드를 사용해 컴포넌트의 메소드를 호출한다.

## 스레드 관리가 필요한 이유
- 프레임워크를 사용하더라도 필요.
- 프레임워크를 사용하면, 제어의 역전에 의해 프로그램 코드가 호출되는 방식으로 작동한다. 
- 프로그램이 호출되면 내부의 상태가 변경된다. 
- 프로그램이 호출에 응답하는 경로상의 모든 컴포넌트가 상태 변경에 영향. 
- 스레드 안정성은 전염성이 있다. 
	
## 스윙
> GUI 어플리케이션은 본질적으로 비동기적으로 비동기적으로 작동한다. 사용자는 언제든지 메뉴를 선택하고 버튼을 누를 수도 있다. 또 어플리케이션이 다른 일을 하는 도중에도 즉각 반응하길 원한다. 이 때문에 스윙과 AWT는 사용자가 발생시킨 이벤트를 처리하거나 사용자가 보는 그래픽을 갱신하기 위해 별도 스레드를 생성해 작업을 맡긴다. 

## 스레드 안전성
- 상태
- 상태에 대한 접근
- 데이터에 대한 제어없이 동시에 상태에 접근하는 것을 통

## 성능 최적화에 대해
> 하지만 이런 경우 항상 코드를 올바르게 작성하는 일이 먼저이고, 
그 다음 필요한 만큼 성능을 개선해야 한다 . 또 최적화는 성능 측정을 해본 이후에 요구 사항에 미달될 때만 하는편이 좋다. 실제와 동일한 상황을 구현해 
성능을 측정하고, 예상되는 수치가 목표 수치와 차이가 있을 때만 적용해야 한다. 
## 명세 - 정확하게 동작한다
- Invariants
- Post Condition

## 단일 작업
### 변경 손실 문제
- e.g.) count++
- 사실은 세가지의 작업이 합쳐진것.
- 1. count 값을 읽어온다. 
- 2. 읽어온 값을 변경한다. 
- 3. 변경된 값을 저장한다. 
- 여러개의 스레드가 참여하는 환경이라면, 각 작업 사이에 무언가 끼어들 수 있다. 
	
### 경쟁조건
- 상황에 따라 정확성이 달라짐.
- check then act 가 예시. 
	check 를 하고 check 된 내용을 바탕으로 act 를 할때, check 된 내용이 유효하지 않아지는 것. 

### 복합동작
- 경쟁조건이 생기는 동작들.
- 더 이상 나뉠 수 없는 하나의 연산, 즉 단일 연산으로 처리해야함.

## 락
- 상태를 전부 스레드 안전한 객체로 관리.
- 이것만으로는 충분하지 않다. 
- 하나의 연산에서 상태 변수가 여러개 변경되는 경우가 있을 수 있다. 
- 이 경우, 각각은 스레드 안전성이 있다.
- 하지만, 연산은 경쟁조건에 놓이게 된다. 
- 연산에 있는 모든 작업에 대해 동기화가 필요하다. 
	
### synchronized
```java
synchronized(lock) {
	// lock 으로 보호된 공유 상태에 접근하거나 해당 상태를 수정한다. 
}
```
- 자바에 내장된 락을 암묵적인 락이라고 한다. 
	
### synchronized 키워드를 메서드에 붙이면 어떻게 될까
- 해당 메서드를 가진 객체를 lock 으로 한다.

### 재진입성
- 암묵적인 락은 재진입이 가능하다. 
- 특정 스레드가 이미 가진 락을 다시 확보할 수 있다. 
- 즉, 락을 얻는 것이 확보 요청 단위가 아닌 스레드 단위 임을 의미한다. 

재진입성이 없다면 다음과 같은 단순한 코드도 데드락에 빠지게 된다. 
```java
public class Widget {
	public synchronized void doSomething() {
		// ...
	}
}

public class LoggingWidget extends Widget {
	public synchronized void doSomething() {
		System.out.println(toString() + ": calling doSomething");
		super.doSomething();
	}
}
```

LoggingWidget 의 인스턴스를 실행한다고 하자.   
`doSomething`을 실행할때, 스레드는 인스턴스를 락으로 확보한다. 
`doSomething`에서 `super`의 `doSomething`을 호출하고 있고,  
이것 역시, `synchronized` 키워드로 보호되고 있으므로, 
동일한 인스턴스를 락으로 확보하기 위해 요청을 보내게 된다.  
만약 재 진입성이 없다면, 하위의 `doSomething`이 끝나지 않았기 때문에,  
데드락에 빠지게 된다.  

## 락으로 보호하기
- 여러 스레드에서 변경 가능한 상태는 반드시 하나의 락으로 보호되어야 한다. 

## 활동성과 성능
- synchronized 로 보호되는 범위를 늘리면, 활동성에 문제가 생길 수 있다.

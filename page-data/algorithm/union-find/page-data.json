{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/algorithm/union-find/","result":{"data":{"markdownRemark":{"html":"<h2>풀고자 하는 문제</h2>\n<p>두개의 대상이 서로 같은 집합에 속하는지 빠르게 판단하고 싶은 경우에 사용한다. 그래프에서 두 노드 사이에 연결이 존재하는지를 판단할때 활용한다.</p>\n<h2>자료구조의 인터페이스</h2>\n<p><code>union(a:Node, b:Node)</code>과 <code>isConnected(a: Node, b: Node)</code>를 public method로 설계할 수 있다.</p>\n<blockquote>\n<ul>\n<li>union(a, b) 는 두 지점을 연결시키는 메서드이다.</li>\n<li>isConnected(a, b) 는 두 지점이 연결되어 있는지 (같은 connected component에 속하는지) 여부를 반환한다.</li>\n</ul>\n</blockquote>\n<h2>알고리즘</h2>\n<h3>Quick find</h3>\n<p>이름처럼 <code>isConnected</code> 연산의 시간복잡도가 <code>O(1)</code>으로 빠른 연산이다. 대신에 <code>union</code> 연산의 시간복잡도가 높다. 구체적인 사항은 다음과 같다.</p>\n<blockquote>\n<ul>\n<li>노드 수 만큼의 배열을 준비한다.</li>\n<li>대표 아이디 배열을 초기화 한다. 인덱스가 노드 번호이고 값은 노드가 속한 component의 대표 아이디이다.</li>\n<li>isConnected 연산에서는 두개의 노드가 서로 같은 대표 아이디를 가졌는지 확인하면 된다> - union 연산의 경우, 두 인덱스의 값을 하나로 통일시켜주고, 두 노드가 속한 컴포넌트 값을 가진 인덱스들을 모두가 같은 값으로 만들어야 한다.</li>\n</ul>\n</blockquote>\n<h2>Quick union</h2>\n<p><code>union</code>연산의 시간복잡도를 낮추고 <code>isConnected</code> 연산의 시간복잡도를 늘린 경우이다.</p>\n<blockquote>\n<ul>\n<li><code>isConnected</code> 연산의 경우 두 노드의 루트가 같은지를 검사한다.</li>\n<li><code>union</code> 연산은 두개의 값을 둘 중 하나로 통일 시키면 된다.</li>\n</ul>\n</blockquote>\n<h2>Quick union weighted</h2>\n<p>불행히도 위 두 알고리즘 모두 느리다. 가중치를 주는 방식을 통해서 빠른 알고리즘으로 변화시킬 수 있다. 가중치는 해당 컴포넌트에 속하는 노드의 개수로, 원소의 개수가 작은 쪽이 더아래로 가레된다.</p>","frontmatter":{"slug":"/algorithm/union-find","title":"union find 알고리즘에 대해 알아보자"}}},"pageContext":{"id":"a731203d-384b-538c-87de-55f7ff0fe763","frontmatter__slug":"/algorithm/union-find","__params":{"frontmatter__slug":"algorithm"}}},"staticQueryHashes":["3957493746"]}
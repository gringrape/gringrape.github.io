{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/bit-manipulation/","result":{"data":{"markdownRemark":{"html":"<h2>실험의 필요성</h2>\n<p>비트 연산의 경우 활용 빈도가 높지는 않다. 따라서, 피드백을 빠르게\n받을 수 있는 도구가 필요하다. 지금 필요한 도구의 요건은 세가지 정도이다.</p>\n<ul>\n<li>bit 연산이 가능할 것.</li>\n<li>연산의 결과를 즉시 확인할 수 있을 것.</li>\n<li>연산의 결과 역시 비트 형태로 확인이 될 것.</li>\n</ul>\n<h3>Java REPL - JShell 이용</h3>\n<p>Integer의 다음 method를 이용하면 2진수 표현으로 변환가능.\n<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toBinaryString-int-\">https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toBinaryString-int-</a></p>\n<p>REPL 에서 간단한 함수를 정의해서 사용하자.</p>\n<pre><code class=\"language-java\">String toBinary(int number) {\n\treturn Integer.toBinaryString(number);\n}\n</code></pre>\n<p>이것도 불편한 감이 있다.\n애초에 표현만을 이진수 표현으로 해주면 된다.\n간단한 node.js 프로그램을 만들어서 사용하자.</p>\n<h3>Node.js REPL</h3>\n<p><code>toBinaryString.js</code>:</p>\n<pre><code class=\"language-javascript\">export default function toBinarySting(expression) {\n  const number = eval(expression);\n  return Number(number).toString(2);\n}\n</code></pre>\n<p><code>index.js</code>:</p>\n<pre><code>/* eslint-disable no-constant-condition */\n\nimport createPrompt from 'prompt-sync';\n\nimport toBinaryString from './toBinaryString.js';\n\nconst { log: print } = console;\n\nconst prompt = createPrompt();\n\nasync function main() {\n  print('Bitwise operations REPL');\n  print('------------------------------');\n\n  while (true) {\n    const expression = prompt('> ');\n\n    if (expression === 'exit') {\n      break;\n    }\n\n    print(toBinaryString(expression));\n  }\n\n  print('bye bye~');\n}\n\nmain();\n\n</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/53764714/191968021-61110517-27b0-439a-b060-6d0effb60932.png\" alt=\"image\"></p>\n<h2>실험 하기</h2>\n<p>실험 환경이 마련되었으니, 실험에 들어가도록 하자.</p>\n<p>첫번째는 bitwise and, 모든 bit position의 값을 비교해서, 둘 모두\n1 인 경우에만 1 로 처리한다.</p>\n<img width=\"725\" alt=\"image\" src=\"https://user-images.githubusercontent.com/53764714/191974698-f1f5168d-6a6f-41d9-b189-c83079e9a73f.png\">\n<p>두번째는 bitwise left shift, bit를 한칸 왼쪽으로 민다.</p>\n<img width=\"725\" alt=\"image\" src=\"https://user-images.githubusercontent.com/53764714/191975227-f6877e0e-07a8-46a1-80c9-efac90790e6c.png\">\n<h2>bit 표현을 boolean 배열로 활용하자</h2>\n<pre><code class=\"language-javascript\">const checker = 0;\n</code></pre>\n<p>위와 같은 값은 bit 표현으로 본다면, bit 자리수 만큼의 0이 존재하는 상황이라고 해석할 수 있다. 만약, 6번째 bit에 0 대신 1을 할당하고자 한다면 방법이 뭘까?</p>\n<p>일단, 6번째 bit를 1로 만드는 연산이 필요하다.</p>\n<pre><code class=\"language-javascript\">1 &#x3C;&#x3C; 6 // 1000000\n</code></pre>\n<p>그 후에 <code>checker</code>와 bitwise or 연산으로 비교를 한다면, 6번째 bit 자리에 1을 할당할 수 있게된다.</p>\n<pre><code class=\"language-javascript\">const checker = 0;\nchecker |= (1 &#x3C;&#x3C; 6) // 1000000 \n</code></pre>\n<p>특정 bit 자리의 값을 읽어오는 연산은 어떻게 할까?\nbitwise and를 통해서 해당 자리의 숫자만을 검증할 수 있다.</p>\n<pre><code class=\"language-javascript\">const check = 8;\nchecker &#x26; (1 &#x3C;&#x3C; 3) // 1000 => 0 보다 크다\n</code></pre>","frontmatter":{"slug":"/bit-manipulation","title":"비트 연산"}}},"pageContext":{"id":"f7e90e21-eee3-52d2-a456-85c2c37eee5b","frontmatter__slug":"/bit-manipulation","__params":{"frontmatter__slug":"bit-manipulation"}}},"staticQueryHashes":["3957493746"]}
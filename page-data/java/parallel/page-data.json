{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/java/parallel/","result":{"data":{"markdownRemark":{"html":"<h2>스레드를 사용하는 예시</h2>\n<blockquote>\n<p>서블릿이나 RMI 같은 컴포넌트 프레임웍 역시 스레드를 관리하는 풀을 여러 개 생성하고 이 스레드를 사용해 컴포넌트의 메소드를 호출한다.</p>\n</blockquote>\n<h2>스레드 관리가 필요한 이유</h2>\n<ul>\n<li>프레임워크를 사용하더라도 필요.</li>\n<li>프레임워크를 사용하면, 제어의 역전에 의해 프로그램 코드가 호출되는 방식으로 작동한다.</li>\n<li>프로그램이 호출되면 내부의 상태가 변경된다.</li>\n<li>프로그램이 호출에 응답하는 경로상의 모든 컴포넌트가 상태 변경에 영향.</li>\n<li>스레드 안정성은 전염성이 있다.</li>\n</ul>\n<h2>스윙</h2>\n<blockquote>\n<p>GUI 어플리케이션은 본질적으로 비동기적으로 비동기적으로 작동한다. 사용자는 언제든지 메뉴를 선택하고 버튼을 누를 수도 있다. 또 어플리케이션이 다른 일을 하는 도중에도 즉각 반응하길 원한다. 이 때문에 스윙과 AWT는 사용자가 발생시킨 이벤트를 처리하거나 사용자가 보는 그래픽을 갱신하기 위해 별도 스레드를 생성해 작업을 맡긴다.</p>\n</blockquote>\n<h2>스레드 안전성</h2>\n<ul>\n<li>상태</li>\n<li>상태에 대한 접근</li>\n<li>데이터에 대한 제어없이 동시에 상태에 접근하는 것을 통</li>\n</ul>\n<h2>성능 최적화에 대해</h2>\n<blockquote>\n<p>하지만 이런 경우 항상 코드를 올바르게 작성하는 일이 먼저이고,</p>\n</blockquote>\n<p>그 다음 필요한 만큼 성능을 개선해야 한다 . 또 최적화는 성능 측정을 해본 이후에 요구 사항에 미달될 때만 하는편이 좋다. 실제와 동일한 상황을 구현해\n성능을 측정하고, 예상되는 수치가 목표 수치와 차이가 있을 때만 적용해야 한다.</p>\n<h2>명세 - 정확하게 동작한다</h2>\n<ul>\n<li>Invariants</li>\n<li>Post Condition</li>\n</ul>\n<h2>단일 작업</h2>\n<h3>변경 손실 문제</h3>\n<ul>\n<li>e.g.) count++</li>\n<li>사실은 세가지의 작업이 합쳐진것.</li>\n<li>\n<ol>\n<li>count 값을 읽어온다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>읽어온 값을 변경한다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>변경된 값을 저장한다.</li>\n</ol>\n</li>\n<li>여러개의 스레드가 참여하는 환경이라면, 각 작업 사이에 무언가 끼어들 수 있다.</li>\n</ul>\n<h3>경쟁조건</h3>\n<ul>\n<li>상황에 따라 정확성이 달라짐.</li>\n<li>check then act 가 예시.\ncheck 를 하고 check 된 내용을 바탕으로 act 를 할때, check 된 내용이 유효하지 않아지는 것.</li>\n</ul>\n<h3>복합동작</h3>\n<ul>\n<li>경쟁조건이 생기는 동작들.</li>\n<li>더 이상 나뉠 수 없는 하나의 연산, 즉 단일 연산으로 처리해야함.</li>\n</ul>\n<h2>락</h2>\n<ul>\n<li>상태를 전부 스레드 안전한 객체로 관리.</li>\n<li>이것만으로는 충분하지 않다.</li>\n<li>하나의 연산에서 상태 변수가 여러개 변경되는 경우가 있을 수 있다.</li>\n<li>이 경우, 각각은 스레드 안전성이 있다.</li>\n<li>하지만, 연산은 경쟁조건에 놓이게 된다.</li>\n<li>연산에 있는 모든 작업에 대해 동기화가 필요하다.</li>\n</ul>\n<h3>synchronized</h3>\n<pre><code class=\"language-java\">synchronized(lock) {\n\t// lock 으로 보호된 공유 상태에 접근하거나 해당 상태를 수정한다. \n}\n</code></pre>\n<ul>\n<li>자바에 내장된 락을 암묵적인 락이라고 한다.</li>\n</ul>\n<h3>synchronized 키워드를 메서드에 붙이면 어떻게 될까</h3>\n<ul>\n<li>해당 메서드를 가진 객체를 lock 으로 한다.</li>\n</ul>\n<h3>재진입성</h3>\n<ul>\n<li>암묵적인 락은 재진입이 가능하다.</li>\n<li>특정 스레드가 이미 가진 락을 다시 확보할 수 있다.</li>\n<li>즉, 락을 얻는 것이 확보 요청 단위가 아닌 스레드 단위 임을 의미한다.</li>\n</ul>\n<p>재진입성이 없다면 다음과 같은 단순한 코드도 데드락에 빠지게 된다.</p>\n<pre><code class=\"language-java\">public class Widget {\n\tpublic synchronized void doSomething() {\n\t\t// ...\n\t}\n}\n\npublic class LoggingWidget extends Widget {\n\tpublic synchronized void doSomething() {\n\t\tSystem.out.println(toString() + \": calling doSomething\");\n\t\tsuper.doSomething();\n\t}\n}\n</code></pre>\n<p>LoggingWidget 의 인스턴스를 실행한다고 하자.<br>\n<code>doSomething</code>을 실행할때, 스레드는 인스턴스를 락으로 확보한다.\n<code>doSomething</code>에서 <code>super</code>의 <code>doSomething</code>을 호출하고 있고,<br>\n이것 역시, <code>synchronized</code> 키워드로 보호되고 있으므로,\n동일한 인스턴스를 락으로 확보하기 위해 요청을 보내게 된다.<br>\n만약 재 진입성이 없다면, 하위의 <code>doSomething</code>이 끝나지 않았기 때문에,<br>\n데드락에 빠지게 된다.</p>\n<h2>락으로 보호하기</h2>\n<ul>\n<li>여러 스레드에서 변경 가능한 상태는 반드시 하나의 락으로 보호되어야 한다.</li>\n</ul>\n<h2>활동성과 성능</h2>\n<ul>\n<li>synchronized 로 보호되는 범위를 늘리면, 활동성에 문제가 생길 수 있다.</li>\n</ul>","frontmatter":{"slug":"/java/parallel","title":"자바 병렬 프로그래밍 기본 원리"}}},"pageContext":{"id":"fbeec6d6-552c-5642-b8d1-d8a98c126d76","frontmatter__slug":"/java/parallel","__params":{"frontmatter__slug":"java"}}},"staticQueryHashes":[]}
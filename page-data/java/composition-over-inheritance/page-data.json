{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/java/composition-over-inheritance/","result":{"data":{"markdownRemark":{"html":"<h1>목차</h1>\n<ul>\n<li>상속의 위험성</li>\n<li>상속의 대안</li>\n<li>상속을 쓰는 것이 좋은 경우</li>\n</ul>\n<h2>상속의 위험성</h2>\n<p>상속은 부모 객체의 캡슐화가 지켜지지 않기 때문에 위험하다. 예를 들어, HashSet을 상속하는 다음 코드를 보자.</p>\n<pre><code class=\"language-java\">public class InstrumentedHashSet&#x3C;E> extends HashSet&#x3C;E> {\n    private int addCount = 0;\n\n    @Override\n    public boolean add(E e) {\n        addCount += 1;\n        return super.add(e);\n    }\n\n    @Override\n    public boolean addAll(Collection&#x3C;? extends E> c) {\n        addCount += c.size();\n        return super.addAll(c);\n    }\n\n    public int getAddCount() {\n        return addCount;\n    }\n}\n</code></pre>\n<p>이 경우, <code>addAll()</code>을 실행했을때, addCount의 값은 정상적으로 계산되지 않는다. 그 이유는, 부모 클래스의 <code>addAll()</code> 구현을 살펴보면 알 수 있다.</p>\n<pre><code class=\"language-java\">public boolean addAll(Collection&#x3C;? extends E> c) {\n        boolean modified = false;\n        for (E e : c)\n            if (add(e))\n                modified = true;\n        return modified;\n    }\n</code></pre>\n<p><code>addAll()</code>의 구현은 <code>add()</code>를 기반으로 이루어지고 있다. <code>add()</code> 호출이 자식 클래스를 호출하게 되므로, <code>addCount</code>가 이중으로 계산되는 것을 알 수 있다.</p>\n<h2>상속의 대안 - 조합</h2>\n<p>상속의 문제점이 구현 상세에 의존하게 되는 것이므로, 구현 상세보다 규약에 의존하도록 수정할 필요가 있다. 인터페이스 타입의 private field를 활용하면, 구현 상세에 의존하지 않으면서도 다른 객체를 확장하는 용도로 사용할 수 있다.</p>\n<p>인터페이스 타입을 사용하기 때문에, 런타임까지 구체적 의존성 주입이 지연되어, 다형성의 효과도 누릴 수 있게 된다.</p>\n<h2>상속을 쓰는 것이 좋은 경우</h2>\n<p>상속은 자식 클래스와 부모 클래스간에 is-a 관계가 성립하는 경우에만, 사용하는 것이 좋다. 예를 들어, 사자는 동물이기 때문에, <code>Lion</code> 클래스는 <code>Animal</code> 클래스의 상속으로 적당하다.</p>","frontmatter":{"slug":"/java/composition-over-inheritance","title":"상속보다 조합을 사용하는 것이 좋은 이유"}}},"pageContext":{"id":"660fcfbc-bb07-5ae5-bfd9-f09ed5c00c90","frontmatter__slug":"/java/composition-over-inheritance","__params":{"frontmatter__slug":"java"}}},"staticQueryHashes":[]}
{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/java/lock-based-concurrency/","result":{"data":{"markdownRemark":{"html":"<h2>방법들</h2>\n<ul>\n<li>synchronized collection</li>\n<li>concurrent collection</li>\n</ul>\n<h2>concurrent collection</h2>\n<ul>\n<li>기존의 락 기반의 클래스들과 비교해서 퍼포먼스 적으로 장점이 있다.</li>\n<li>기존의 락은 상태에 대한 모든 연산에 대해서 한번에 하나의 스레드만 접근 할 수 있도록 한다.</li>\n<li>concurrent collection의 경우에는 동시에 여러 스레드의 접근을 허용한다는 것이 핵심이다.</li>\n<li>읽기 스레드는 쓰기 스레드와 동시에 접근할 수 있다.</li>\n<li>그리고 제한된 수의 쓰기 스레드만이 작업을 완료할 수 있다.</li>\n</ul>\n<h3>tradeoff</h3>\n<ul>\n<li>size, isEmpty 와 같은 메서드의 의미 약화.</li>\n<li>동시적 특성 때문에 size를 계산하는 중에 값이 바뀔 수 있다.</li>\n<li>그래서 size는 추정치로 보아야 한다.</li>\n</ul>\n<h2>참고</h2>\n<ul>\n<li>Java Concurrency In Practice</li>\n</ul>","frontmatter":{"slug":"/java/lock-based-concurrency","title":"Java 락 기반 병렬성 제어 방법들"}}},"pageContext":{"id":"7438b516-ae5d-548e-8ff7-755b9612fe76","frontmatter__slug":"/java/lock-based-concurrency","__params":{"frontmatter__slug":"java"}}},"staticQueryHashes":["3957493746"]}
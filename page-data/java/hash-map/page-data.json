{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/java/hash-map/","result":{"data":{"markdownRemark":{"html":"<h2>HashMap의 구현</h2>\n<ul>\n<li>시간 복잡도\n<ul>\n<li><code>get</code>, <code>put</code> 연산에서 상수시간 복잡도를 가짐.</li>\n<li><code>values</code> method와 같이 collection view에 대한 iteration의 경우에는 bucket size에 해당하는 시간 복잡도를 가지기 때문에, <code>load factor</code>를 너무 낮게 설정하거나, <code>capacity</code>를 너무 크게 설정하지 않아야 함.</li>\n</ul>\n</li>\n<li>load factor\n<ul>\n<li>0.75가 기본값</li>\n<li>사용하는 공간과 lookup cost 사이의 trade off. collection view 연산의 경우는 load factor가 작고 공간을 많이 사용하면 느려짐.</li>\n<li>많은 수의 자료를 다룰 거라면, capacity를 넉넉하게 설정하는 것이, 작게 설정해서 rehashing으로 인한 overhead가 일어나게 하는 것보다 낫다.</li>\n</ul>\n</li>\n<li>hash collision 해결\n<ul>\n<li>linked list 이용하는 방식 -> tree로 바뀌는 threshold가 존재함.</li>\n<li>bucket을 그대로 이용하는 방식</li>\n<li>bucket 자체의 사이즈를 늘리는 메커니즘 존재 -> load factor</li>\n</ul>\n</li>\n<li>Collection view에 의해서 반환되는 iterator는 fail fast로 설계\n<ul>\n<li>fail fast iterator란 collection이 iterator를 통하지 않고 수정되었을때, 이를 감지해서 빠르게 예외를 던지며 실패하는 것.</li>\n</ul>\n</li>\n</ul>\n<h2>참고</h2>\n<ul>\n<li>HashMap 스펙 - <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html\">https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html</a></li>\n<li>The Java Programming Language 4/e - 21.2 Iteration - fail fast iterator에 관함.</li>\n</ul>","frontmatter":{"slug":"/java/hashMap","title":"자바 HashMap은 어떻게 구현되어 있을까?"}}},"pageContext":{"id":"d601c42f-2615-5cc3-ba10-6ca1838a6d73","frontmatter__slug":"/java/hashMap","__params":{"frontmatter__slug":"java"}}},"staticQueryHashes":[]}
{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/ostep/5-limited-direct-execution/","result":{"data":{"markdownRemark":{"html":"<h2>직접 실행의 문제점</h2>\n<ul>\n<li>사용자 프로세스가 시스템 전반의 권한을 모두 가지게 할 수는 없다. 보호가 필요.</li>\n<li>시분할을 하기 위해서는 현재 실행되는 프로세스를 바꿔 줄 필요가 있다.</li>\n</ul>\n<h2>\"Limited\" Direct Execution</h2>\n<ul>\n<li>직접 실행에서 야기되는 문제를 해결하기 위해, 추가적인 메커니즘이 필요.</li>\n<li>이런 메커니즘들은 <code>Restriction</code>이라고 볼 수 있다.</li>\n<li>따라서 제한된 직접 실행이라는 표현을 활용함.</li>\n</ul>\n<h2>프로세스가 할 수 있는 일의 제한</h2>\n<ul>\n<li>권한을 나눠서, 해당 권한에서 할 수 있는 일만 하자.</li>\n<li><code>User mode</code>와 <code>Kernel mode</code>를 나눈다.</li>\n<li>시스템 호출과 같이 중요한 것은 <code>Kernel mode</code>에서 수행한다.</li>\n<li>프로세스에서 시스템 호출이 필요한 경우? -> <code>Trap instruction</code> 을 활용한다.</li>\n<li>커널에서 필요한 시스템 호출을 수행한 후에 <code>Return trap instruction</code>을 통해서 다시 프로세스로 돌아온다.</li>\n</ul>\n<h2>프로세스 전환</h2>\n<ul>\n<li>협력적인 설계 -> 프로세스가 명시적인 시스템 호출을 통해 제어권을 운영체제에 넘겨준다.</li>\n<li>비협력적인 설계 -> 일정시간이 지나면, 제어권이 강제로 운영체제로 넘어온다.</li>\n<li>메커니즘은 비슷, 현재 실행되고 있는 프로세스의 상태를 저장하고, 실행될 프로세스의 상태를 복원하는 것.</li>\n</ul>","frontmatter":{"slug":"/ostep/5-limited-direct-execution","title":"Limited direct execution 에 대해 알아보자"}}},"pageContext":{"id":"19cfa31b-f325-5bc6-9ce7-ffc60c3b04d2","frontmatter__slug":"/ostep/5-limited-direct-execution","__params":{"frontmatter__slug":"ostep"}}},"staticQueryHashes":[]}
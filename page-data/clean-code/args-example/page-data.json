{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/clean-code/args-example/","result":{"data":{"markdownRemark":{"html":"<h2>목표</h2>\n<blockquote>\n<p>인수분석기의 리팩토링과정을 관찰하며 변경의 이유를 배우자.</p>\n</blockquote>\n<p>리팩토링 과정을 관찰하기 위해서는 TDD로 진행하는 것이 필요하다.</p>\n<p>하지만, 책에는 테스트까지 실려있지는 않다. 다음 저장소에서 해당 내용을 참고 할 수 있도록 하자.</p>\n<p><a href=\"https://github.com/ludwiggj/CleanCode\">https://github.com/ludwiggj/CleanCode</a></p>\n<h2>초안</h2>\n<p>Boolean 인수를 처리하는 초안을 만들기.</p>\n<h3>하나의 인수를 입력</h3>\n<p>인수를 설정했을 경우와 하지 않았을 경우의 테스트를 작성할 수 있다.</p>\n<p><code>ArgsTest.java</code>:</p>\n<pre><code class=\"language-java\">@Test\nvoid singleBooleanArgumentSet() {\n    Args args = new Args(\"x\", new String[]{\"-x\"});\n    assertThat(args.getBoolean('x')).isTrue();\n}\n\n@Test\nvoid singleBooleanArgumentUnset() {\n    Args args = new Args(\"x\", new String[]{\"\"});\n    assertThat(args.getBoolean('x')).isFalse();\n}\n\n</code></pre>\n<p>구현에서는 스키마와 인수목록을 입력받아 각각을 해석하는 것이 큰 흐름이다.</p>\n<p><code>Args.java</code>:</p>\n<pre><code class=\"language-java\">public Args(String schema, String[] args) {\n    booleanArgs = new HashMap&#x3C;>();\n\n    this.schema = schema;\n    this.args = args;\n\n    parse();\n}\n\nprivate void parse() {\n    parseSchema();\n    parseArguments();\n}\n</code></pre>\n<p>여러 인수들에 대한 테스트도 추가해주자. 이 때, cardinality 개념도 이용할 수 있는데, 이것은 수학적으로 원소의 개수를 뜻하는 개념이다.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Cardinality\">https://en.wikipedia.org/wiki/Cardinality</a></p>\n<p><code>ArgsTest.java</code>:</p>\n<pre><code class=\"language-java\">@Test\nvoid multipleBooleanArguments() {\n    Args args = new Args(\"x,y,z\", new String[]{\"-xy\"});\n\n    assertThat(args.getBoolean('x')).isTrue();\n    assertThat(args.getBoolean('y')).isTrue();\n    assertThat(args.getBoolean('z')).isFalse();\n\n    assertThat(args.cardinality()).isEqualTo(3);\n}\n</code></pre>\n<p>구현은 다음과 같이 해줄 수 있다. <code>cardinality</code>는 개념적으로 총 인수의 개수를 나타내지만 현재는 boolean 타입의 인수만을 지원하므로, 다음과 같이 작성하도록 한다.</p>\n<p><code>Args.java</code>:</p>\n<pre><code class=\"language-java\">public int cardinality() {\n    return booleanArgs.size();\n}\n</code></pre>\n<p>이제 오류인 경우를 추가해보자. 오류의 유형과 처리 방법을 결정해야 한다.\n책에서는 오류 유형을 다음과 같이 정의했다.</p>\n<blockquote>\n<p>기대하지 않은 인수가 입력되었다.</p>\n</blockquote>\n<p>기대하지 않았다는 것은 해당 인수가 스키마에 정의되어있지 않다는 뜻이다.\n다음과 같은 테스트를 작성할 수 있다.</p>\n<pre><code class=\"language-java\">@Test\nvoid validArguments() {\n    Args args = new Args(\"x\", new String[]{\"-x\"});\n\n    assertThat(args.isValid()).isTrue();\n\n    assertThat(args.errorMessage()).isEqualTo(\"\");\n}\n\n@Test\nvoid invalidArguments() {\n    Args args = new Args(\"\", new String[]{\"-xy\"});\n\n    assertThat(args.isValid()).isFalse();\n\n    assertThat(args.errorMessage()).isEqualTo(\"Argument(s) -xy unexpected.\");\n}\n\n</code></pre>\n<p>구현은 다음과 같이 해 줄수 있다. 기대하지 않은 인수를 포함해서 오류메시지를 작성한다.</p>\n<pre><code class=\"language-java\">public String errorMessage() {\n    if (unexpectedArguments.isEmpty()) {\n        return \"\";\n    }\n\n    StringBuilder arguments = new StringBuilder();\n    for (char unexpectedArgument : unexpectedArguments) {\n        arguments.append(unexpectedArgument);\n    }\n    return \"Argument(s) -\" + arguments + \" unexpected.\";\n}\n\n</code></pre>\n<h2>코드</h2>\n<h3>Boolean 인수 분석 초안</h3>\n<p><a href=\"https://github.com/gringrape/coding-life/tree/main/20221014/clean-code-args-example\">https://github.com/gringrape/coding-life/tree/main/20221014/clean-code-args-example</a></p>","frontmatter":{"slug":"/clean-code/args-example","title":"클린코드- Args 예제"}}},"pageContext":{"id":"d3784ce1-03b0-5cd3-89f8-656620bef273","frontmatter__slug":"/clean-code/args-example","__params":{"frontmatter__slug":"clean-code"}}},"staticQueryHashes":["3957493746"]}
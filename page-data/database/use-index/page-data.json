{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/database/use-index/","result":{"data":{"markdownRemark":{"html":"<h1>데이터 베이스 인덱스</h1>\n<h2>인덱스는 무엇일까?</h2>\n<p>데이터를 효율적으로 탐색하기 위한 자료구조를 뜻한다. 본래의 데이터와는 별도의 데이터 구조이다. 모든 인덱스는 본래 데이터와 별도로 구성되고 유지되어야 하기 때문에 그 자체로 오버헤드가 발생한다.</p>\n<p>특히, 데이터 추가 등의 변경 연산은 인덱스도 변경해야 하므로, 인덱스는 변경 연산의 속도를 낮춘다.</p>\n<h2>인덱스를 구성하기 좋은 경우</h2>\n<p>데이터의 <code>cardinality</code>가 인덱스의 효율에 영향을 미친다. <code>cardinality</code>는 어떤 칼럼에 대해 서로 구분되는 값들이 얼마나 존재하는지를 나타내는 척도이다. 이 값이 높을 수록 인덱스로서의 쓸모는 커진다.</p>\n<h2>Hash Index</h2>\n<p><code>log structured storage engine</code>에서 사용되는 인덱스이다. <code>log</code>는 데이터의 <code>append</code>만 일어나는 파일을 말한다. 때문에 인덱스를 구성할때, 찾으려는 키와 바이트 오프셋을 해시 테이블로 관리해서 쿼리 효율을 높인다.</p>\n<p>사용하려는 key 종류가 많을때 이러한 방식은 문제가 된다. 메모리에 모든 키를 저장해놓고 써야 하는데 이로인해 공간을 많이 사용하게 되는 문제가 있다. <code>SSTable</code>을 이용하면 이런 문제를 해결하는데 도움이 된다.</p>\n<p><code>SSTable</code>에서는 key 값이 정렬된 상태로 존재하므로, 인덱스에 모든 key를 저장할 필요가 없게 된다. 정렬된 key를 가진 sparse hash table을 사용할 수 있다. 찾으려고 하는 키가 sparse hash table의 두 키 사이에 있다면, 해당 위치의 탐색을 통해서 찾을 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/53764714/209679397-9221ccc2-5714-4c09-82b8-78ce9dd91973.png\" alt=\"\"></p>\n<p>이렇게 사이에 존재하는지 (존재하지 않는지) 판별하는 메커니즘을 <code>bloom filter</code>라고 한다.</p>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://www.freecodecamp.org/news/database-indexing-at-a-glance-bb50809d48bd/\">https://www.freecodecamp.org/news/database-indexing-at-a-glance-bb50809d48bd/</a></li>\n<li>데이터 중심 어플리케이션 설계 Chapter3</li>\n</ul>","frontmatter":{"slug":"/database/use-index","title":"어떤 인덱스가 좋은 인덱스일까?"}}},"pageContext":{"id":"53017696-9711-5c26-bc4d-f477ad433bb3","frontmatter__slug":"/database/use-index","__params":{"frontmatter__slug":"database"}}},"staticQueryHashes":[]}
{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/ctci/1-4/","result":{"data":{"markdownRemark":{"html":"<h2>회문 순열의 특징</h2>\n<ul>\n<li>같은 문자는 반드시 짝수번 등장한다.</li>\n</ul>\n<h2>풀이 구상</h2>\n<ul>\n<li>문자의 등장 횟수를 센다. -> 짝수번 등장하는지 검사한다.</li>\n<li>등장 회수를 세는 수단은 해시 테이블이 있다.</li>\n<li>비트벡터를 이용해서 셀 수도 있다.</li>\n</ul>\n<h2>비트벡터를 이용한 풀이</h2>\n<h3>비트벡터의 테스트 작성</h3>\n<p>이번 문제에서는 특정 자리의 수를 반전 시키는 toggle 연산이 필요하다.</p>\n<pre><code class=\"language-java\">@Test\nvoid toggle() {\n    BitVector vector = new BitVector();\n\n    assertEquals(vector.get(2), 0);\n\n    vector.toggle(2);\n\n    assertEquals(vector.get(2), 1);\n\n    vector.toggle(2);\n\n    assertEquals(vector.get(2), 0);\n}\n\n</code></pre>\n<p>toggle 연산은 XOR 연산자를 이용하면 쉽게 할 수 있다.\nXOR 연산은 피연산자와 연산자가 다르면 1, 같으면 0을 반환한다.</p>\n<p>그렇기 때문에 연산자가 0 이라면 원래숫자를 그대로 유지하고,\n연산자가 1이라면, 원래의 숫자가 반전되는 특성이 있다.</p>\n<pre><code class=\"language-java\">public void toggle(int index) {\n    bits ^= (1 &#x3C;&#x3C; index);\n}\n</code></pre>\n<p>이것을 이용한 최종 풀이는 다음과 같다.</p>\n<pre><code class=\"language-java\">boolean isPalindromeAnagram(String word) {\n     BitVector bits = new BitVector();\n\n     for (char letter : word.toCharArray()) {\n         int index = letter - 'a';\n         bits.toggle(index);\n     }\n\n     return bits.sumOfDigits() &#x3C;= 1;\n }\n\n</code></pre>\n<h2>새롭게 알게된 것</h2>\n<h3>mask</h3>\n<p>다음과 같은 것을 mask 라고 부른다는 것을 관찰.\nmask와 &#x26; 연산을 하는 경우, 특정 자리의 값만 남고 나머지가 0이 되어 '가려지기' 때문인 것 같다.</p>\n<pre><code class=\"language-java\">int mask = 1 &#x3C;&#x3C; index;\n</code></pre>\n<blockquote>\n<p>Using a mask, multiple bits in a byte, nibble, word, etc. can be set either on or off, or inverted from on to off (or vice versa) in a single bitwise operation.</p>\n</blockquote>\n<p>mask 를 이용하면, 여러개의 비트를 일괄적으로 on/off 할 수 있다.</p>\n<blockquote>\n<p>More often in practice, bits are \"masked off\" (or masked to 0) than \"masked on\" (or masked to 1). When a bit is ANDed with a 0, the result is always 0, i.e. Y AND 0 = 0. To leave the other bits as they were originally, they can be ANDed with 1 as Y AND 1 = Y</p>\n</blockquote>\n<p>0 과 and 연산을 이용하면,  masked off 처리를 할 수 있다.</p>\n<h3>값이 1인 bit가 한번만 등장하는지 알아내는 방법</h3>\n<p>값이 1인 bit가 오직 한번만 등장하는 경우들의 예를 들어보자.</p>\n<pre><code>1\n10\n100\n1000\n10000\n100000\n</code></pre>\n<p>위의 숫자들에서 1을 빼보자.</p>\n<pre><code>0\n01\n011\n0111\n01111\n011111\n</code></pre>\n<p>원래 숫자와 <code>&#x26;</code> 연산을 하면, 값이 0이 되는 효과가 나타난다.</p>\n<h2>어떤 문자열이 특정 그룹(회문 순열)에 속하는지 판단하는 방법</h2>\n<p>가장 쉽게 생각할 수 있는 것은, 문자열의 순서를 바꾼 순열을 모두 구해서\n회문이 되는지 판단하는 것이다. 하지만, 꼭 모든 경우의 수를 구해야 하는 것은 아니다.<br>\n회문 순열이 갖는 일반적인 규칙을 파악하고, 문자열이 해당 규칙을 만족하는지를 체크하면,<br>\n모든 경우의 수를 구하지 않고도 문제를 해결할 수 있다.</p>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Mask_(computing)\">https://en.wikipedia.org/wiki/Mask_(computing)</a></li>\n</ul>","frontmatter":{"slug":"/ctci/1-4","title":"회문 순열"}}},"pageContext":{"id":"641e0291-c7d7-5f65-8ad4-64c782f45fb0","frontmatter__slug":"/ctci/1-4","__params":{"frontmatter__slug":"ctci"}}},"staticQueryHashes":[]}
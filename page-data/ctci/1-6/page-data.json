{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/ctci/1-6/","result":{"data":{"markdownRemark":{"html":"<h2>문자열을 압축하기</h2>\n<ul>\n<li><code>현재 문자</code>와 <code>개수</code>를 기록한다.</li>\n<li>문자가 달라지면 개수를 초기화 한다.</li>\n<li>결과 문자열을 하나 만든다.</li>\n</ul>\n<h2>결과 문자열을 이어 붙이는 방식</h2>\n<p>문자열은 불변이기 때문에, 효율성이 좋지 않다.\n가볍게 풀어보자.</p>\n<h3>문자열 이어붙이기의 대안</h3>\n<p>string의 join 메서드\n<a href=\"https://docs.python.org/3/library/stdtypes.html?highlight=join#str.join\">https://docs.python.org/3/library/stdtypes.html?highlight=join#str.join</a></p>\n<p>index를 활용하면 풀이를 개선할 수 있다.</p>\n<h3>시간 복잡도의 탐구</h3>\n<p>문자열 이어붙이기의 시간복잡도는 문자열의 길이가 n인 경우 n ** 2 이 된다.</p>\n<p>문자열 압축의 경우, 같은 문자가 연속되는 부분을 segment 라고 한다면,<br>\nsegment의 개수만큼 문자열 이어붙이기가 일어나게 된다.</p>\n<p>따라서, segment의 개수를 k라고 한다면, 시간복잡도는 k ** 2이 된다.</p>\n<h2>풀이</h2>\n<pre><code class=\"language-python\">def zip_string(string):\n    pairs = []\n\n    count = 0\n    for i in range(len(string)):\n        if i &#x3C; len(string) - 1 and string[i] == string[i + 1]:\n            count += 1\n            continue\n\n        pairs.append((string[i], count + 1))\n        count = 0\n\n    zipped = \"\".join((letter + str(count) for letter, count in pairs))\n\n    return zipped if len(zipped) &#x3C; len(string) else string\n</code></pre>","frontmatter":{"slug":"/ctci/1-6","title":"문자열 압축"}}},"pageContext":{"id":"09450b78-05ec-5b02-a3a3-c61682644de6","frontmatter__slug":"/ctci/1-6","__params":{"frontmatter__slug":"ctci"}}},"staticQueryHashes":[]}
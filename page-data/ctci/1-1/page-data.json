{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/ctci/1-1/","result":{"data":{"markdownRemark":{"html":"<h2>문제</h2>\n<p>문자열에 같은 문자가 중복되어 등장하는지 확인하는 알고리즘 작성.</p>\n<h3>힌트를 어떻게 활용해야 할까?</h3>\n<p>힌트는 책 뒤편에 찾아볼 수 있도록 실려있다.</p>\n<h2>문제 접근</h2>\n<p>문제의 이해.</p>\n<ul>\n<li>주어진 것 - 문자열.</li>\n<li>구하는 것 - 주어진 문자열에 같은 문자가 중복되어 등장하는지 여부.</li>\n</ul>\n<h2>풀이 1. set 자료 구조를 이용한다.</h2>\n<p>set 은 존재 여부를 빠르게 탐색O(1) 할 수 있는 수단이다.</p>\n<h3>풀이 구상</h3>\n<ol>\n<li>문자를 담는 set 구조를 마련한다.</li>\n<li>문자열을 순회하며 set 구조에 해당 문자가 있는지 파악한다.</li>\n<li>있으면 true 반환, 없으면 set에 해당 문자를 담고 계속 진행.</li>\n</ol>\n<h3>풀이 실천</h3>\n<p>python 을 이용해서 빠르게 구현해보자.</p>\n<pre><code class=\"language-python\">def has_duplicate_letters_1(string):\n    distinct_letters = set()\n\n    for l in string:\n        if l in distinct_letters:\n            return True\n        distinct_letters.add(l)\n\n    return False\n</code></pre>\n<h2>풀이 2.</h2>\n<p>brute force 방식으로 전부 비교한다.</p>\n<pre><code class=\"language-python\">def has_duplicate_letters_brute_force(string):\n    for i in range(len(string)):\n        for j in range(i + 1, len(string)):\n            if string[i] == string[j]:\n                return True\n    return False\n</code></pre>\n<h2>풀이 3.</h2>\n<p>set 을 이용할때, 문자열의 모든 글자를 넣어두면\n표현이 더 심플해진다.</p>\n<pre><code class=\"language-python\">def has_duplicate_letters_set_compare_length(string):\n    distinct_letters = set(string)\n    return len(string) > len(distinct_letters)\n</code></pre>\n<h2>풀이 4.</h2>\n<p>문제에 주어진 힌트인 #132 를 적용해보자.</p>\n<blockquote>\n<p><code>O(N log N)</code>에 풀어내기.</p>\n</blockquote>\n<p>이러한 시간 복잡도를 갖는 것은 정렬을 생각해 볼 수 있다.</p>\n<pre><code class=\"language-python\">def has_duplicate_letters_sorting(string):\n    string_in_lexicographic_order = sorted(string)\n\n    return any(\n        string_in_lexicographic_order[i] == string_in_lexicographic_order[i + 1]\n        for i in range(len(string) - 1)\n    )\n</code></pre>\n<h2>해법의 힌트들</h2>\n<h3>문자개수가 유한함을 이용할 수 있다</h3>\n<p>문자 개수 공간 만큼의 boolean 배열을 미리 구성해놓고,\n배열을 순회하며, 존재여부를 업데이트 할 수 있다.</p>\n<p>이 경우 시간 복잡도는 O(N), 공간 복잡도는 O(1)이 된다.</p>\n<h3>비트벡터를 활용한다</h3>\n<p>비트벡터를 이용하면, 사용하는 저장공간을 훨씬 줄일 수 있다.\nboolean 배열은 여러개의 비트 공간을 의미할 수 있다.</p>\n<h2>python 풀이</h2>\n<ul>\n<li><a href=\"https://github.com/gringrape/coding-life/blob/main/20220923/ctci-1-1/python/test_has_duplicate_letters.py\">https://github.com/gringrape/coding-life/blob/main/20220923/ctci-1-1/python/test_has_duplicate_letters.py</a></li>\n</ul>\n<h2>평범한 Array 를 활용한 풀이</h2>\n<pre><code class=\"language-java\">boolean hasDuplicateLettersArray(String string) {\n    boolean[] checker = new boolean[string.length()];\n    for (int i = 0; i &#x3C; string.length(); i += 1) {\n        char l = string.charAt(i);\n        int index = l - 'a';\n        if (checker[index]) {\n            return true;\n        }\n        checker[index] = true;\n    }\n    return false;\n}\n</code></pre>\n<h2>비트벡터를 활용한 풀이</h2>\n<pre><code class=\"language-java\">boolean hasDuplicateLettersBit(String string) {\n    int checker = 0;\n    for (int i = 0; i &#x3C; string.length(); i += 1) {\n        char l = string.charAt(i);\n        int index = l - 'a';\n        if ((checker &#x26; (1 &#x3C;&#x3C; index)) > 0) {\n            return true;\n        }\n        checker |= (1 &#x3C;&#x3C; index);\n    }\n    return false;\n}\n\n</code></pre>\n<h2>참고</h2>\n<ul>\n<li>python sorting - <a href=\"https://docs.python.org/3/howto/sorting.html\">https://docs.python.org/3/howto/sorting.html</a></li>\n<li>python any - <a href=\"https://docs.python.org/3/library/functions.html\">https://docs.python.org/3/library/functions.html</a></li>\n</ul>","frontmatter":{"slug":"/ctci/1-1","title":"중복이 없는가"}}},"pageContext":{"id":"3b118f02-445e-52d9-b6c7-3640d63f80ae","frontmatter__slug":"/ctci/1-1","__params":{"frontmatter__slug":"ctci"}}},"staticQueryHashes":[]}
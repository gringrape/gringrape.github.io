{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/ctci/1-1/","result":{"data":{"markdownRemark":{"html":"<h2>문제 출처</h2>\n<p>코딩인터뷰 완전분석 1-1번 문제</p>\n<h2>문제 설명</h2>\n<p>문자열에 같은 문자가 중복되어 등장하는지 확인하는 알고리즘 작성하는 것이 과제이다.</p>\n<h2>풀이 1. set 자료 구조를 이용한다.</h2>\n<p>set 은 존재 여부를 빠르게 탐색O(1) 할 수 있는 수단이다. 글자를 순차적으로 넣으면서, 넣으려고 하는 글자가 set에 이미 존재하는지를 확인하면 된다.</p>\n<h3>풀이 구상</h3>\n<ol>\n<li>문자를 담는 set 구조를 마련한다.</li>\n<li>문자열을 순회하며 set 구조에 해당 문자가 있는지 파악한다.</li>\n<li>있으면 true 반환, 없으면 set에 해당 문자를 담고 계속 진행.</li>\n</ol>\n<h3>풀이 실천</h3>\n<p>python 을 이용해서 빠르게 구현해보자.</p>\n<pre><code class=\"language-python\">def has_duplicate_letters_1(string):\n    distinct_letters = set()\n\n    for l in string:\n        if l in distinct_letters:\n            return True\n        distinct_letters.add(l)\n\n    return False\n</code></pre>\n<h2>풀이 2.</h2>\n<p>brute force 방식으로 전부 비교한다.</p>\n<pre><code class=\"language-python\">def has_duplicate_letters_brute_force(string):\n    for i in range(len(string)):\n        for j in range(i + 1, len(string)):\n            if string[i] == string[j]:\n                return True\n    return False\n</code></pre>\n<h2>풀이 3.</h2>\n<p>set 을 이용할때, 문자열의 모든 글자를 넣어두면\n표현이 더 심플해진다.</p>\n<pre><code class=\"language-python\">def has_duplicate_letters_set_compare_length(string):\n    distinct_letters = set(string)\n    return len(string) > len(distinct_letters)\n</code></pre>\n<h2>풀이 4.</h2>\n<p>다음 힌트를 적용해보자. 알고리즘의 시간복잡도에 관한 힌트가 주어져있다.</p>\n<blockquote>\n<p><code>O(N log N)</code>에 풀어내기.</p>\n</blockquote>\n<p>이러한 시간 복잡도를 갖는 것은 정렬을 생각해 볼 수 있다. 문자열의 글자들을 정렬해서 현재 문자와 다음 문자가 같다면, 문자가 중복되어 있다고 판단할 수 있다.</p>\n<pre><code class=\"language-python\">def has_duplicate_letters_sorting(string):\n    string_in_lexicographic_order = sorted(string)\n\n    return any(\n        string_in_lexicographic_order[i] == string_in_lexicographic_order[i + 1]\n        for i in range(len(string) - 1)\n    )\n</code></pre>\n<h2>추가적인 풀이 방법들</h2>\n<h3>set 대신에 boolean 배열 이용</h3>\n<p>문자 개수 공간 만큼의 boolean 배열을 미리 구성해놓고, 배열을 순회하면서 등장 여부를 업데이트 할 수 있다.</p>\n<p>처음에는 등장여부를 담는 <code>checker</code>배열의 값이 모두 <code>false</code> 였다가, 문자가 등장하면 해당 index의 값을 <code>true</code>로 바꾼다. 만약, 현재 index의 값이 <code>true</code>라면, 이 문자는 중복된 것임을 확인할 수 있다.</p>\n<p>이 경우 시간 복잡도는 O(N), 공간 복잡도는 O(1)이 된다.</p>\n<pre><code class=\"language-java\">boolean hasDuplicateLettersArray(String string) {\n    boolean[] checker = new boolean[string.length()];\n    for (int i = 0; i &#x3C; string.length(); i += 1) {\n        char l = string.charAt(i);\n        int index = l - 'a';\n        if (checker[index]) {\n            return true;\n        }\n        checker[index] = true;\n    }\n    return false;\n}\n</code></pre>\n<h3>boolean 배열 대신에 비트벡터 활용</h3>\n<p>비트벡터를 이용하면, boolean 배열과 같은 기능을 하면서,  사용하는 저장공간을 훨씬 줄일 수 있다.</p>\n<pre><code class=\"language-java\">boolean hasDuplicateLettersBit(String string) {\n    int checker = 0;\n    for (int i = 0; i &#x3C; string.length(); i += 1) {\n        char l = string.charAt(i);\n        int index = l - 'a';\n        if ((checker &#x26; (1 &#x3C;&#x3C; index)) > 0) {\n            return true;\n</code></pre>\n<h2>풀이 코드 링크</h2>\n<ul>\n<li><a href=\"https://github.com/gringrape/coding-life/blob/main/20220923/ctci-1-1/python/test_has_duplicate_letters.py\">https://github.com/gringrape/coding-life/blob/main/20220923/ctci-1-1/python/test_has_duplicate_letters.py</a></li>\n</ul>\n<h2>참고</h2>\n<ul>\n<li>python sorting - <a href=\"https://docs.python.org/3/howto/sorting.html\">https://docs.python.org/3/howto/sorting.html</a></li>\n<li>python any - <a href=\"https://docs.python.org/3/library/functions.html\">https://docs.python.org/3/library/functions.html</a></li>\n</ul>","frontmatter":{"slug":"/ctci/1-1","title":"코딩인터뷰 완전분석 문제풀이 - 중복이 없는가"}}},"pageContext":{"id":"115357b5-1b8c-59f1-a9f4-cbfc556ec30d","frontmatter__slug":"/ctci/1-1","__params":{"frontmatter__slug":"ctci"}}},"staticQueryHashes":[]}